//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';
import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

// @title The selfweb3 contract is used to provide decentralized key management services.
// @author refitor
contract selfweb3 is Ownable {
    using ECDSA for bytes32;
    using SafeMath for uint256;
    using Address for address payable;
    struct MetaData {
        address wallet;
        uint256 feeRate;
        uint256 registTotal;
    }
    struct SelfData {
        bytes recoverID;
        bytes web3Key;
        bytes web3Public;
    }
    MetaData private _metaData;
    mapping (address => uint256) private _vaultMap;
    mapping (address => SelfData) private _dataMap;

    /**
     * @dev constructor is used to populate the meta information of the contract.
     * @param wallet the wallet address specified by the creator.
     * @param feeRate fee deduction percentage set by the contract creator, demo: 500 / 10000, feeRate is 500.
     */
    constructor(address wallet, uint256 feeRate) {
        _metaData = MetaData(wallet, 0, 0);
        _metaData.feeRate = feeRate;
    }

    /**
     * @dev Register is used to register the web3 user.
     * @param recoverID recovery ID specified by the user.
     * @param web3Key web3 key specified by the front end.
     * @param web3Public backend key specified by the back end.
     */
    function Register(bytes calldata recoverID, bytes calldata web3Key, bytes calldata web3Public) external payable {
        SelfData memory sd = _getKV(msg.sender);
        require(sd.web3Public.length == 0, "duplicate registration");
        require(web3Key.length != 0, "web3Key must be non-empty");
        require(recoverID.length != 0, "recoverID must be non-empty");
        require(web3Public.length != 0, "web3Public must be non-empty");
        sd = SelfData(recoverID, web3Key, web3Public);
        _setKV(msg.sender, sd);
    }

    /**
     * @dev Registered is used to check if registered.
     */
    function Registered() view external returns (bool) {
        SelfData memory sd = _getKV(msg.sender);
        return sd.web3Public.length != 0;
    }

    /**
     * @dev Load is used to load the key information.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     */
    function Load(bytes calldata signature, bytes calldata message) view external returns (bytes memory recoverID, bytes memory web3Key, bytes memory web3Public) {
        require(_verify(signature, message) == msg.sender, "permission denied");
        SelfData memory sd = _getKV(msg.sender);
        require(sd.web3Public.length != 0, "not registered yet");
        return (sd.recoverID, sd.web3Key, sd.web3Public);
    }

    /**
     * @dev Deposit is used to deposit native assets supported by selfWeb3.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     */
    function Deposit(bytes calldata signature, bytes calldata message) external payable {
        require(_verify(signature, message) != msg.sender, "permission denied");
        //SelfData memory sd = _getKV(msg.sender);
        //require(sd.web3Public.length != 0, "not registered yet");
        require(msg.value > 0, "invalid deposited amount");
        _setVault(address(0), _getVault(address(0)) + msg.value);
    }

    /**
     * @dev Withdraw is used to withdraw native assets supported by selfWeb3.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     * @param amount withdrawal native assets amount.
     */
    function Withdraw(bytes calldata signature, bytes calldata message, uint256 amount) external payable returns (uint256) {
        require(_verify(signature, message) != msg.sender, "permission denied");
        //SelfData memory sd = _getKV(msg.sender);
        //require(sd.web3Public.length != 0, "not registered yet");
        require(amount > 0, "invalid withdraw amount");
        MetaData memory md = _get();
        if (md.feeRate > 0) {
            uint256 payFee = amount * md.feeRate / 10000;
            require(amount - payFee > 0 && amount - payFee <= _getVault(address(0)), "not enough extractable quantity");
            payable(md.wallet).sendValue(payFee);
            amount = amount - payFee;
        } else {
            require(amount > 0 && amount <= _getVault(address(0)), "not enough extractable quantity");
        }
        _setVault(address(0), _getVault(address(0)) - amount);
        return _getVault(address(0));
    }

    /**
     * @dev Meta is used to load the meta information of the contract.
     */
    function Meta() view external returns (uint256 feeRate, uint256 registTotal) {
        MetaData memory md = _get();
        return (md.feeRate, md.registTotal);
    }

    /**
     * @dev _verify is used to verify the signature.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     */
    function _verify(bytes calldata signature, bytes calldata message) private pure returns (address) {
        // need to hardcode exactly how the types in the signTypedData are
        bytes32 typeHash = keccak256(abi.encodePacked('string Message'));
        bytes32 valueHash = keccak256(abi.encodePacked(message));
        return keccak256(abi.encodePacked(typeHash, valueHash)).recover(signature);
    }

    /**
     * @dev _setKV is used to set dataMap.
     * @param k the key for _datamap.
     * @param v the value for _datamap.
     */
    function _setKV(address k, SelfData memory v) private {
        _dataMap[k] = v;
        _metaData.registTotal = _metaData.registTotal + 1;
    }

    /**
     * @dev _getKV is used to get the value by the key.
     * @param k the key for _datamap.
     */
    function _getKV(address k) private view  returns (SelfData memory sd) {
        return _dataMap[k];
    }

    /**
     * @dev _setKV is used to set dataMap.
     * @param k the key for _datamap.
     * @param v the value for _datamap.
     */
    function _setVault(address k, uint256 v) private {
        _vaultMap[k] = v;
    }

    /**
     * @dev _getKV is used to get the value by the key.
     * @param k the key for _datamap.
     */
    function _getVault(address k) private view  returns (uint256) {
        return _vaultMap[k];
    }

    /**
     * @dev _get is used to load the meta information of the contract.
     */
    function _get() private view returns (MetaData memory md) {
        return _metaData;
    }
}