//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";

import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

// @title The selfweb3 contract is used to provide decentralized key management services.
// @author refitor
contract selfweb3 is Ownable {
    using ECDSA for bytes32;
    using SafeMath for uint256;
    using Address for address payable;
    struct MetaData {
        uint256 nonce;
        uint256 registTotal;
    }
    struct SelfData {
        bytes recoverID;
        bytes web3Key;
        bytes web3Public;
        uint256 verifyNonce;
        address wallet;
    }
    struct RelateVerifyParam {
        bytes32 root;
        uint256 nonce;
        bytes32[] proof;
    }
    MetaData private _metaData;
    mapping (bytes => SelfData) private _dataMap;

    /**
     * @dev constructor is used to populate the meta information of the contract.
     * @param nonce System initialization random number.
     */
    constructor(uint256 nonce) {
        _metaData = MetaData(nonce, 0);
    }

    /**
     * @dev Register is used to register the web3 user.
     * @param selfID unique user ID.
     * @param recoverID recovery ID specified by the user.
     * @param web3Key web3 key specified by the front end.
     * @param web3Public backend key specified by the back end.
     */
    function Register(bytes calldata selfID, bytes calldata recoverID, bytes calldata web3Key, bytes calldata web3Public, uint256 nonce) external payable {
        require(web3Key.length != 0, "web3Key must be non-empty");
        require(recoverID.length != 0, "recoverID must be non-empty");
        require(web3Public.length != 0, "web3Public must be non-empty");
        require(nonce > 0, "verify nonce must be bigger than zero");
        SelfData memory sd = _getKV(selfID);
        require(sd.web3Public.length == 0, "duplicate registration");
        sd = SelfData(recoverID, web3Key, web3Public, nonce, msg.sender);
        _setKV(selfID, sd);
    }

    /**
     * @dev Load is used to load the key information.
     * @param selfID unique user ID.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     */
    function Load(bytes calldata selfID, bytes calldata signature, bytes calldata message) view external returns (bytes memory recoverID, bytes memory web3Public) {
        SelfData memory sd = _getKV(selfID);
        require(sd.web3Public.length != 0, "not registered yet");
        require(_sigVerify(signature, message) == sd.wallet, "permission denied");
        return (sd.recoverID, sd.web3Public);
    }

    /**
     * @dev Rebind is used to rebind the wallet.
     * @param selfID unique user ID.
     * @param wallet the old wallet address.
     * @param rvparam is the parameter for on-chain association verification
     */
    function Rebind(bytes calldata selfID, address wallet, bytes calldata rvparam) external payable {
        SelfData memory sd = _getKV(selfID);
        require(wallet == sd.wallet, "permission denied with invalid wallet");
        require(sd.web3Public.length != 0, "not registered yet");
        RelateVerifyParam memory rvp = abi.decode(rvparam, (RelateVerifyParam));
        require(_relateVerify(selfID, rvp.root, rvp.proof, rvp.nonce, 0) == true, "associated validation failed");
        sd = SelfData(sd.recoverID, sd.web3Key, sd.web3Public, sd.verifyNonce, msg.sender);
        _setKV(selfID, sd);
    }

    /**
     * @dev Load is used to load the key information.
     * @param selfID unique user ID.
     * @param rvparam is the parameter for on-chain association verification
     */
    function Web3Key(bytes calldata selfID, bytes calldata rvparam) view external returns (bytes memory web3Key) {
        require(rvparam.length != 0, "merkleTree root must be non-empty");
        SelfData memory sd = _getKV(selfID);
        require(sd.web3Public.length != 0, "not registered yet");
        RelateVerifyParam memory rvp = abi.decode(rvparam, (RelateVerifyParam));
        require(_relateVerify(selfID, rvp.root, rvp.proof, rvp.nonce, 1) == true, "associated validation failed");
        return sd.web3Key;
    }

    /**
     * @dev Meta is used to load the meta information of the contract.
     */
    function Meta() view external returns (uint256 registTotal) {
        MetaData memory md = _get();
        return md.registTotal;
    }

    /**
     * @dev _verify is used to verify the signature.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     */
    function _sigVerify(bytes calldata signature, bytes calldata message) private pure returns (address) {
        // need to hardcode exactly how the types in the signTypedData are
        bytes32 typeHash = keccak256(abi.encodePacked('string Action'));
        bytes32 valueHash = keccak256(abi.encodePacked(message));
        return keccak256(abi.encodePacked(typeHash, valueHash)).recover(signature);
    }

    /**
     * @dev Verify is an on-chain MerkleTree check for association verification.
     * @param selfID unique user ID.
     * @param root root hash for MerkleTree verification.
     * @param proof List of proofs used for MerkleTree verification.
     * @param dynamicNonce Dynamic random number for association verification
     * @param relateVerifyTimes The number of associated verification backtracks specified by the chain
     */
    function _relateVerify(bytes calldata selfID, bytes32 root, bytes32[] memory proof, uint256 dynamicNonce, uint256 relateVerifyTimes) private view returns (bool) {
        require(root.length != 0, "merkleTree root must be non-empty");
        require(proof.length >= 1, "merkleTree proof must be non-empty");
        SelfData memory sd = _getKV(selfID);
        require(sd.web3Public.length != 0, "not registered yet");

        if (relateVerifyTimes == 0) {
            // merkle tree verify, support verification of sender reliability
            if (MerkleProof.verify(proof, root, keccak256(bytes.concat(keccak256(abi.encode(uint256(_metaData.nonce * 33 + dynamicNonce)))))) == false) {
                return false;
            }
        } else {
            // merkle tree verify, support backtracking for association verification
            for (uint256 i = 0; i < relateVerifyTimes; i++) {
                uint256 leafValue = _metaData.nonce * 33 + sd.verifyNonce + dynamicNonce - i * _metaData.nonce;
                if (MerkleProof.verify(proof, root, keccak256(bytes.concat(keccak256(abi.encode(leafValue))))) == false) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * @dev _setKV is used to set dataMap.
     * @param k the key for _datamap.
     * @param v the value for _datamap.
     */
    function _setKV(bytes calldata k, SelfData memory v) private {
        _dataMap[k] = v;
        _metaData.registTotal = _metaData.registTotal + 1;
    }

    /**
     * @dev _getKV is used to get the value by the key.
     * @param k the key for _datamap.
     */
    function _getKV(bytes calldata k) private view  returns (SelfData memory sd) {
        return _dataMap[k];
    }

    /**
     * @dev _get is used to load the meta information of the contract.
     */
    function _get() private view returns (MetaData memory md) {
        return _metaData;
    }
}